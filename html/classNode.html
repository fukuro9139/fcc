<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FCC: Node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FCC
   </div>
   <div id="projectbrief">x86-64上で動作するLinux向けC言語コンパイラ</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classNode.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="classNode-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Node Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>抽象構文木(AST)を構成するノード  
 <a href="classNode.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="parse_8hpp_source.html">parse.hpp</a>&quot;</code></p>
<div class="dynheader">
Collaboration diagram for Node:</div>
<div class="dyncontent">
<div class="center"><img src="classNode__coll__graph.png" border="0" usemap="#aNode_coll__map" alt="Collaboration graph"/></div>
<map name="aNode_coll__map" id="aNode_coll__map">
<area shape="rect" title="抽象構文木(AST)を構成するノード" alt="" coords="1052,336,1108,363"/>
<area shape="rect" title=" " alt="" coords="485,205,640,232"/>
<area shape="rect" href="classObject.html" title="変数または関数を表す。各オブジェクトは名前によって区別する" alt="" coords="818,411,882,437"/>
<area shape="rect" href="classToken.html" title="トークンを表すクラス" alt="" coords="533,580,592,607"/>
<area shape="rect" title=" " alt="" coords="192,411,339,453"/>
<area shape="rect" title=" " alt="" coords="186,477,345,504"/>
<area shape="rect" title=" " alt="" coords="180,528,351,555"/>
<area shape="rect" title=" " alt="" coords="217,579,314,605"/>
<area shape="rect" title=" " alt="" coords="5,496,64,523"/>
<area shape="rect" href="structToken_1_1File.html" title="ファイルを表す構造体" alt="" coords="220,360,311,387"/>
<area shape="rect" title=" " alt="" coords="190,269,341,296"/>
<area shape="rect" title=" " alt="" coords="763,461,937,488"/>
<area shape="rect" title=" " alt="" coords="480,331,645,373"/>
<area shape="rect" title=" " alt="" coords="481,397,644,424"/>
<area shape="rect" title=" " alt="" coords="489,449,637,490"/>
<area shape="rect" title=" " alt="" coords="489,514,637,555"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad7a34779cad45d997bfd6d3d8043c75f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad7a34779cad45d997bfd6d3d8043c75f">Node</a> ()</td></tr>
<tr class="separator:ad7a34779cad45d997bfd6d3d8043c75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ab0694366f91241d1c6e58c2ec047a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad0ab0694366f91241d1c6e58c2ec047a">Node</a> (const int64_t &amp;val, const shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; &amp;ty, <a class="el" href="classToken.html">Token</a> *token)</td></tr>
<tr class="separator:ad0ab0694366f91241d1c6e58c2ec047a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d16b6ca1a91a8467542932eff00d1ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a4d16b6ca1a91a8467542932eff00d1ca">Node</a> (const int64_t &amp;val, <a class="el" href="classToken.html">Token</a> *token)</td></tr>
<tr class="separator:a4d16b6ca1a91a8467542932eff00d1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0cd7b0188c6e9e93dfcfa3e3c19947"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a5e0cd7b0188c6e9e93dfcfa3e3c19947">Node</a> (const <a class="el" href="parse_8hpp.html#adaa4ecec941fa446d7019c24371f4ff0">NodeKind</a> &amp;kind, <a class="el" href="classToken.html">Token</a> *token)</td></tr>
<tr class="separator:a5e0cd7b0188c6e9e93dfcfa3e3c19947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83405d72fc70460afc3a5c88e35f5115"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a83405d72fc70460afc3a5c88e35f5115">Node</a> (const <a class="el" href="parse_8hpp.html#adaa4ecec941fa446d7019c24371f4ff0">NodeKind</a> &amp;kind, unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &amp;&amp;lhs, <a class="el" href="classToken.html">Token</a> *token)</td></tr>
<tr class="separator:a83405d72fc70460afc3a5c88e35f5115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675d820589eb5f44ebe6a89a155dd9e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a675d820589eb5f44ebe6a89a155dd9e1">Node</a> (const <a class="el" href="parse_8hpp.html#adaa4ecec941fa446d7019c24371f4ff0">NodeKind</a> &amp;kind, unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &amp;&amp;lhs, unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &amp;&amp;rhs, <a class="el" href="classToken.html">Token</a> *token)</td></tr>
<tr class="separator:a675d820589eb5f44ebe6a89a155dd9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583c3f3c759c6da54635c704660de8f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a583c3f3c759c6da54635c704660de8f6">Node</a> (const <a class="el" href="classObject.html">Object</a> *var, <a class="el" href="classToken.html">Token</a> *token)</td></tr>
<tr class="separator:a583c3f3c759c6da54635c704660de8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae11ea1ada6e842418ef5ba9ac54e15ae"><td class="memItemLeft" align="right" valign="top">static int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ae11ea1ada6e842418ef5ba9ac54e15ae">const_expr</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:ae11ea1ada6e842418ef5ba9ac54e15ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">定数式を読み取って評価する  <a href="classNode.html#ae11ea1ada6e842418ef5ba9ac54e15ae">More...</a><br /></td></tr>
<tr class="separator:ae11ea1ada6e842418ef5ba9ac54e15ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263d7bc3fbe5f8ddd49462e23dbf0ae4"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a263d7bc3fbe5f8ddd49462e23dbf0ae4">new_cast</a> (unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &amp;&amp;expr, const shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; &amp;ty)</td></tr>
<tr class="memdesc:a263d7bc3fbe5f8ddd49462e23dbf0ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">型キャストに対応するノードを作成する  <a href="classNode.html#a263d7bc3fbe5f8ddd49462e23dbf0ae4">More...</a><br /></td></tr>
<tr class="separator:a263d7bc3fbe5f8ddd49462e23dbf0ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8828892e50da48890283a6ddce025ade"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classObject.html">Object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a8828892e50da48890283a6ddce025ade">parse</a> (const unique_ptr&lt; <a class="el" href="classToken.html">Token</a> &gt; &amp;list)</td></tr>
<tr class="memdesc:a8828892e50da48890283a6ddce025ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">トークン・リストを構文解析して関数ごとにASTを構築する  <a href="classNode.html#a8828892e50da48890283a6ddce025ade">More...</a><br /></td></tr>
<tr class="separator:a8828892e50da48890283a6ddce025ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ada3ab21e3538e4b8a943cf2cc440ef81"><td class="memItemLeft" align="right" valign="top">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ada3ab21e3538e4b8a943cf2cc440ef81">_args</a></td></tr>
<tr class="separator:ada3ab21e3538e4b8a943cf2cc440ef81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11dead16c5974879fa828e5ce0281e95"><td class="memItemLeft" align="right" valign="top">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a11dead16c5974879fa828e5ce0281e95">_body</a></td></tr>
<tr class="separator:a11dead16c5974879fa828e5ce0281e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80f88cea76bf1bfe8437975e5412100"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ae80f88cea76bf1bfe8437975e5412100">_brk_label</a> = &quot;&quot;</td></tr>
<tr class="separator:ae80f88cea76bf1bfe8437975e5412100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdc6401f50b06af1c56b2362aef46a1"><td class="memItemLeft" align="right" valign="top">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a2cdc6401f50b06af1c56b2362aef46a1">_condition</a></td></tr>
<tr class="separator:a2cdc6401f50b06af1c56b2362aef46a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fea8833104226bc686ae8f46c7a711e"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a9fea8833104226bc686ae8f46c7a711e">_cont_label</a> = &quot;&quot;</td></tr>
<tr class="separator:a9fea8833104226bc686ae8f46c7a711e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0743a59be6b4d130d9842b46c3bf0a"><td class="memItemLeft" align="right" valign="top">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a5c0743a59be6b4d130d9842b46c3bf0a">_else</a></td></tr>
<tr class="separator:a5c0743a59be6b4d130d9842b46c3bf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b06a9efee3d2c68d8de039b3ca0f0d"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a86b06a9efee3d2c68d8de039b3ca0f0d">_func_ty</a></td></tr>
<tr class="separator:a86b06a9efee3d2c68d8de039b3ca0f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea97216fc8d04a37148b2082674c339"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a2ea97216fc8d04a37148b2082674c339">_fval</a> = 0.0</td></tr>
<tr class="separator:a2ea97216fc8d04a37148b2082674c339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fad0e27643627ba57ef7071ba759e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNode.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad5fad0e27643627ba57ef7071ba759e1">_goto_next</a></td></tr>
<tr class="separator:ad5fad0e27643627ba57ef7071ba759e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7a4cc5b409a7d26a40cbcad7d20614"><td class="memItemLeft" align="right" valign="top">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7f7a4cc5b409a7d26a40cbcad7d20614">_inc</a></td></tr>
<tr class="separator:a7f7a4cc5b409a7d26a40cbcad7d20614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc97b2c849452e3c4bb78ea99e7d0da"><td class="memItemLeft" align="right" valign="top">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#acdc97b2c849452e3c4bb78ea99e7d0da">_init</a></td></tr>
<tr class="separator:acdc97b2c849452e3c4bb78ea99e7d0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab539992ca576dcd1209a7dbe15323b96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="parse_8hpp.html#adaa4ecec941fa446d7019c24371f4ff0">NodeKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ab539992ca576dcd1209a7dbe15323b96">_kind</a> = <a class="el" href="parse_8hpp.html#adaa4ecec941fa446d7019c24371f4ff0afbe8a298d9587617545741b4c0309b24">NodeKind::ND_EXPR_STMT</a></td></tr>
<tr class="separator:ab539992ca576dcd1209a7dbe15323b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb3743c53a6214c7bc795ec6f54d63a"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aacb3743c53a6214c7bc795ec6f54d63a">_label</a> = &quot;&quot;</td></tr>
<tr class="separator:aacb3743c53a6214c7bc795ec6f54d63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90719b3c8189235c17ed5b1db87d7df2"><td class="memItemLeft" align="right" valign="top">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a90719b3c8189235c17ed5b1db87d7df2">_lhs</a></td></tr>
<tr class="separator:a90719b3c8189235c17ed5b1db87d7df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dd03d1e2278a2ed7579fe699c4384d"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; <a class="el" href="structMember.html">Member</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a80dd03d1e2278a2ed7579fe699c4384d">_member</a></td></tr>
<tr class="separator:a80dd03d1e2278a2ed7579fe699c4384d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62631002faea754d2d59eb087b50ce94"><td class="memItemLeft" align="right" valign="top">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a62631002faea754d2d59eb087b50ce94">_next</a></td></tr>
<tr class="separator:a62631002faea754d2d59eb087b50ce94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fae819c089409c1678af9bfe036ae89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7fae819c089409c1678af9bfe036ae89">_pass_by_stack</a> = false</td></tr>
<tr class="separator:a7fae819c089409c1678af9bfe036ae89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f0a7fea28013d6542eebdd4ae71b9d"><td class="memItemLeft" align="right" valign="top">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a58f0a7fea28013d6542eebdd4ae71b9d">_rhs</a></td></tr>
<tr class="separator:a58f0a7fea28013d6542eebdd4ae71b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76f9f9d2ef94a236500ad737710d515"><td class="memItemLeft" align="right" valign="top">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aa76f9f9d2ef94a236500ad737710d515">_then</a></td></tr>
<tr class="separator:aa76f9f9d2ef94a236500ad737710d515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac4f88922fb98206bef10d97b6f0886"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classToken.html">Token</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a8ac4f88922fb98206bef10d97b6f0886">_token</a> = nullptr</td></tr>
<tr class="separator:a8ac4f88922fb98206bef10d97b6f0886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f00d80b1120c55f138ff212f6d2787e"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a4f00d80b1120c55f138ff212f6d2787e">_ty</a></td></tr>
<tr class="separator:a4f00d80b1120c55f138ff212f6d2787e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d7fdce09faa3d603f50740a4cee876"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a30d7fdce09faa3d603f50740a4cee876">_unique_label</a> = &quot;&quot;</td></tr>
<tr class="separator:a30d7fdce09faa3d603f50740a4cee876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2493055211201a1a42c4ab18795c326"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aa2493055211201a1a42c4ab18795c326">_val</a> = 0</td></tr>
<tr class="separator:aa2493055211201a1a42c4ab18795c326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08b6b660b78ac6fda3cff7b96dc9c30"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classObject.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#af08b6b660b78ac6fda3cff7b96dc9c30">_var</a> = nullptr</td></tr>
<tr class="separator:af08b6b660b78ac6fda3cff7b96dc9c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb6b67041719db08aef7fcf264678b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNode.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aaeb6b67041719db08aef7fcf264678b5">case_next</a> = nullptr</td></tr>
<tr class="separator:aaeb6b67041719db08aef7fcf264678b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2617479440480742cbc734060e8cad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNode.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a3a2617479440480742cbc734060e8cad">default_case</a> = nullptr</td></tr>
<tr class="separator:a3a2617479440480742cbc734060e8cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a711ba9a5637db4998690ae582ceb5d13"><td class="memItemLeft" align="right" valign="top">static shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a711ba9a5637db4998690ae582ceb5d13">abstract_declarator</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token, shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; ty)</td></tr>
<tr class="memdesc:a711ba9a5637db4998690ae582ceb5d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">識別子をもたない仮想的な変数宣言として型情報を読む  <a href="classNode.html#a711ba9a5637db4998690ae582ceb5d13">More...</a><br /></td></tr>
<tr class="separator:a711ba9a5637db4998690ae582ceb5d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd2be583a80290629b0a1cce615292c"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a5dd2be583a80290629b0a1cce615292c">add</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:a5dd2be583a80290629b0a1cce615292c"><td class="mdescLeft">&#160;</td><td class="mdescRight">和を読み取る。  <a href="classNode.html#a5dd2be583a80290629b0a1cce615292c">More...</a><br /></td></tr>
<tr class="separator:a5dd2be583a80290629b0a1cce615292c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd897b0cd52768efa5621d71ab642b5"><td class="memItemLeft" align="right" valign="top">static shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a6cd897b0cd52768efa5621d71ab642b5">array_dimensions</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token, shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; &amp;&amp;ty)</td></tr>
<tr class="memdesc:a6cd897b0cd52768efa5621d71ab642b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">配列の宣言の要素数部分を読み取る  <a href="classNode.html#a6cd897b0cd52768efa5621d71ab642b5">More...</a><br /></td></tr>
<tr class="separator:a6cd897b0cd52768efa5621d71ab642b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf43dab749eb23892af07c8d0021a04"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#accf43dab749eb23892af07c8d0021a04">array_initializer1</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token, <a class="el" href="structObject_1_1Initializer.html">Object::Initializer</a> *init)</td></tr>
<tr class="memdesc:accf43dab749eb23892af07c8d0021a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">配列の変数の初期化式（前後に'{}'を持つ）を読み取りを生成する  <a href="classNode.html#accf43dab749eb23892af07c8d0021a04">More...</a><br /></td></tr>
<tr class="separator:accf43dab749eb23892af07c8d0021a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d01120505dd287c49a3a3337c3fcb0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#af1d01120505dd287c49a3a3337c3fcb0">array_initializer2</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token, <a class="el" href="structObject_1_1Initializer.html">Object::Initializer</a> *init)</td></tr>
<tr class="memdesc:af1d01120505dd287c49a3a3337c3fcb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">配列の変数の初期化式（前後に'{}'を持たない）を読み取り生成する  <a href="classNode.html#af1d01120505dd287c49a3a3337c3fcb0">More...</a><br /></td></tr>
<tr class="separator:af1d01120505dd287c49a3a3337c3fcb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2dd105cfe60d02d1f498d0f18018c8"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a1d2dd105cfe60d02d1f498d0f18018c8">assign</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:a1d2dd105cfe60d02d1f498d0f18018c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">代入式を読み取る。  <a href="classNode.html#a1d2dd105cfe60d02d1f498d0f18018c8">More...</a><br /></td></tr>
<tr class="separator:a1d2dd105cfe60d02d1f498d0f18018c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81f434d44279957730ec41ab67d7b87"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aa81f434d44279957730ec41ab67d7b87">bit_and</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:aa81f434d44279957730ec41ab67d7b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">bitandを読み取る  <a href="classNode.html#aa81f434d44279957730ec41ab67d7b87">More...</a><br /></td></tr>
<tr class="separator:aa81f434d44279957730ec41ab67d7b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc27fa3fe69dd8fc47e66a36df6cdfd"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aebc27fa3fe69dd8fc47e66a36df6cdfd">bit_or</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:aebc27fa3fe69dd8fc47e66a36df6cdfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">bitorを読み取る  <a href="classNode.html#aebc27fa3fe69dd8fc47e66a36df6cdfd">More...</a><br /></td></tr>
<tr class="separator:aebc27fa3fe69dd8fc47e66a36df6cdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7f379d42f3bb4568077ac9d93a6c5a"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#afe7f379d42f3bb4568077ac9d93a6c5a">bit_xor</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:afe7f379d42f3bb4568077ac9d93a6c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">bitxorを読み取る  <a href="classNode.html#afe7f379d42f3bb4568077ac9d93a6c5a">More...</a><br /></td></tr>
<tr class="separator:afe7f379d42f3bb4568077ac9d93a6c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4a318b37151b2cd242f99372409a06"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#abf4a318b37151b2cd242f99372409a06">cast</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:abf4a318b37151b2cd242f99372409a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">型キャストを読み取る  <a href="classNode.html#abf4a318b37151b2cd242f99372409a06">More...</a><br /></td></tr>
<tr class="separator:abf4a318b37151b2cd242f99372409a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2edbb5288a0563b4f25774e1a6da24b"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad2edbb5288a0563b4f25774e1a6da24b">compound_statement</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:ad2edbb5288a0563b4f25774e1a6da24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ブロックを読み取る。  <a href="classNode.html#ad2edbb5288a0563b4f25774e1a6da24b">More...</a><br /></td></tr>
<tr class="separator:ad2edbb5288a0563b4f25774e1a6da24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d35e180a973cee8500708170ea649e9"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7d35e180a973cee8500708170ea649e9">conditional</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:a7d35e180a973cee8500708170ea649e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">3項演算子を読み取る  <a href="classNode.html#a7d35e180a973cee8500708170ea649e9">More...</a><br /></td></tr>
<tr class="separator:a7d35e180a973cee8500708170ea649e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921691ddfc78486a50249c98479c8eda"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a921691ddfc78486a50249c98479c8eda">consume</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token, string &amp;&amp;str)</td></tr>
<tr class="memdesc:a921691ddfc78486a50249c98479c8eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">トークンが期待している文字列と一致する場合は次のトークンのポインタをnext_tokenにセットしtrueを返す。  <a href="classNode.html#a921691ddfc78486a50249c98479c8eda">More...</a><br /></td></tr>
<tr class="separator:a921691ddfc78486a50249c98479c8eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4e5a2b07bde70878d5ee19bf2cc338"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a5e4e5a2b07bde70878d5ee19bf2cc338">consume_end</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:a5e4e5a2b07bde70878d5ee19bf2cc338"><td class="mdescLeft">&#160;</td><td class="mdescRight">トークンが配列、構造体、列挙型の末尾と一致する場合は次のトークンのポインタをnext_tokenにセットしtrueを返す。  <a href="classNode.html#a5e4e5a2b07bde70878d5ee19bf2cc338">More...</a><br /></td></tr>
<tr class="separator:a5e4e5a2b07bde70878d5ee19bf2cc338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d898facee3b78ab884be4079e6e11f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ab3d898facee3b78ab884be4079e6e11f">count_array_init_element</a> (<a class="el" href="classToken.html">Token</a> *token, const <a class="el" href="classType.html">Type</a> *ty)</td></tr>
<tr class="memdesc:ab3d898facee3b78ab884be4079e6e11f"><td class="mdescLeft">&#160;</td><td class="mdescRight">初期化式で与えられた配列の要素数を数える  <a href="classNode.html#ab3d898facee3b78ab884be4079e6e11f">More...</a><br /></td></tr>
<tr class="separator:ab3d898facee3b78ab884be4079e6e11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac907c167a672a4d0eb7d8b5118524884"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ac907c167a672a4d0eb7d8b5118524884">create_lvar_init</a> (<a class="el" href="structObject_1_1Initializer.html">Object::Initializer</a> *init, <a class="el" href="classType.html">Type</a> *ty, <a class="el" href="structObject_1_1InitDesg.html">Object::InitDesg</a> *desg, <a class="el" href="classToken.html">Token</a> *token)</td></tr>
<tr class="memdesc:ac907c167a672a4d0eb7d8b5118524884"><td class="mdescLeft">&#160;</td><td class="mdescRight">ローカル変数を初期化するノードを構成する。  <a href="classNode.html#ac907c167a672a4d0eb7d8b5118524884">More...</a><br /></td></tr>
<tr class="separator:ac907c167a672a4d0eb7d8b5118524884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad583c276c7388fc2599e67cddd05afb0"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad583c276c7388fc2599e67cddd05afb0">declaration</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token, shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; &amp;base, const <a class="el" href="structObject_1_1VarAttr.html">Object::VarAttr</a> *attr)</td></tr>
<tr class="memdesc:ad583c276c7388fc2599e67cddd05afb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">変数宣言を読み取る  <a href="classNode.html#ad583c276c7388fc2599e67cddd05afb0">More...</a><br /></td></tr>
<tr class="separator:ad583c276c7388fc2599e67cddd05afb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bdde7ae2632ef8b8f24a451c1deb35"><td class="memItemLeft" align="right" valign="top">static shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ab6bdde7ae2632ef8b8f24a451c1deb35">declarator</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token, shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; ty)</td></tr>
<tr class="memdesc:ab6bdde7ae2632ef8b8f24a451c1deb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">変数宣言を変数名部分を読み取る  <a href="classNode.html#ab6bdde7ae2632ef8b8f24a451c1deb35">More...</a><br /></td></tr>
<tr class="separator:ab6bdde7ae2632ef8b8f24a451c1deb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bd952f89bd71a593c7be358710dc17"><td class="memItemLeft" align="right" valign="top">static shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#af4bd952f89bd71a593c7be358710dc17">declspec</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token, <a class="el" href="structObject_1_1VarAttr.html">Object::VarAttr</a> *attr)</td></tr>
<tr class="memdesc:af4bd952f89bd71a593c7be358710dc17"><td class="mdescLeft">&#160;</td><td class="mdescRight">変数宣言の型指定子部分を読み取る  <a href="classNode.html#af4bd952f89bd71a593c7be358710dc17">More...</a><br /></td></tr>
<tr class="separator:af4bd952f89bd71a593c7be358710dc17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0085e6c1eef10b0740e264b0ca499d"><td class="memItemLeft" align="right" valign="top">static shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a0d0085e6c1eef10b0740e264b0ca499d">enum_specifier</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:a0d0085e6c1eef10b0740e264b0ca499d"><td class="mdescLeft">&#160;</td><td class="mdescRight">列挙型の定義を読み取る  <a href="classNode.html#a0d0085e6c1eef10b0740e264b0ca499d">More...</a><br /></td></tr>
<tr class="separator:a0d0085e6c1eef10b0740e264b0ca499d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd15962749cca28595bcb2f20216754"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a9bd15962749cca28595bcb2f20216754">equality</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:a9bd15962749cca28595bcb2f20216754"><td class="mdescLeft">&#160;</td><td class="mdescRight">等価比較式を読み取る。  <a href="classNode.html#a9bd15962749cca28595bcb2f20216754">More...</a><br /></td></tr>
<tr class="separator:a9bd15962749cca28595bcb2f20216754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7dc39f4f7460140c7b02b1176866a3"><td class="memItemLeft" align="right" valign="top">static int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a5f7dc39f4f7460140c7b02b1176866a3">evaluate</a> (<a class="el" href="classNode.html">Node</a> *node)</td></tr>
<tr class="memdesc:a5f7dc39f4f7460140c7b02b1176866a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">ノードを定数式として評価  <a href="classNode.html#a5f7dc39f4f7460140c7b02b1176866a3">More...</a><br /></td></tr>
<tr class="separator:a5f7dc39f4f7460140c7b02b1176866a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebda070fc170dec37c8925b8eb97ff9"><td class="memItemLeft" align="right" valign="top">static int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aeebda070fc170dec37c8925b8eb97ff9">evaluate2</a> (<a class="el" href="classNode.html">Node</a> *node, string *label)</td></tr>
<tr class="memdesc:aeebda070fc170dec37c8925b8eb97ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">ノードを定数式として評価  <a href="classNode.html#aeebda070fc170dec37c8925b8eb97ff9">More...</a><br /></td></tr>
<tr class="separator:aeebda070fc170dec37c8925b8eb97ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada84360a6ff9780fa4288fa01d123f1d"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ada84360a6ff9780fa4288fa01d123f1d">evaluate_double</a> (<a class="el" href="classNode.html">Node</a> *node)</td></tr>
<tr class="memdesc:ada84360a6ff9780fa4288fa01d123f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">浮動小数点数型の定数式を評価する  <a href="classNode.html#ada84360a6ff9780fa4288fa01d123f1d">More...</a><br /></td></tr>
<tr class="separator:ada84360a6ff9780fa4288fa01d123f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7296778f03309fd44641a17da72cb24"><td class="memItemLeft" align="right" valign="top">static int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ac7296778f03309fd44641a17da72cb24">evaluate_rval</a> (<a class="el" href="classNode.html">Node</a> *node, string *label)</td></tr>
<tr class="memdesc:ac7296778f03309fd44641a17da72cb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">右辺値を評価する  <a href="classNode.html#ac7296778f03309fd44641a17da72cb24">More...</a><br /></td></tr>
<tr class="separator:ac7296778f03309fd44641a17da72cb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c70f89b4f82254629ac6de91c0c6585"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a0c70f89b4f82254629ac6de91c0c6585">expression</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:a0c70f89b4f82254629ac6de91c0c6585"><td class="mdescLeft">&#160;</td><td class="mdescRight">式を読み取る。  <a href="classNode.html#a0c70f89b4f82254629ac6de91c0c6585">More...</a><br /></td></tr>
<tr class="separator:a0c70f89b4f82254629ac6de91c0c6585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c1b8db1299932bf2536db15c69deec"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a82c1b8db1299932bf2536db15c69deec">expression_statement</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:a82c1b8db1299932bf2536db15c69deec"><td class="mdescLeft">&#160;</td><td class="mdescRight">単文を読み取る。  <a href="classNode.html#a82c1b8db1299932bf2536db15c69deec">More...</a><br /></td></tr>
<tr class="separator:a82c1b8db1299932bf2536db15c69deec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c338e28cdf77942c664dadf4895f30"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a98c338e28cdf77942c664dadf4895f30">function_call</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token, unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &amp;&amp;fn)</td></tr>
<tr class="memdesc:a98c338e28cdf77942c664dadf4895f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">関数呼び出し  <a href="classNode.html#a98c338e28cdf77942c664dadf4895f30">More...</a><br /></td></tr>
<tr class="separator:a98c338e28cdf77942c664dadf4895f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92291df4f4c17be9db9c8aa69179f236"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classToken.html">Token</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a92291df4f4c17be9db9c8aa69179f236">function_definition</a> (<a class="el" href="classToken.html">Token</a> *token, shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; &amp;&amp;base, <a class="el" href="structObject_1_1VarAttr.html">Object::VarAttr</a> *attr)</td></tr>
<tr class="memdesc:a92291df4f4c17be9db9c8aa69179f236"><td class="mdescLeft">&#160;</td><td class="mdescRight">関数宣言、定義を読み取る。  <a href="classNode.html#a92291df4f4c17be9db9c8aa69179f236">More...</a><br /></td></tr>
<tr class="separator:a92291df4f4c17be9db9c8aa69179f236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be7bcd22c1c8a25f4895ec760b34aa4"><td class="memItemLeft" align="right" valign="top">static shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a0be7bcd22c1c8a25f4895ec760b34aa4">function_parameters</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token, shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; &amp;&amp;ty)</td></tr>
<tr class="memdesc:a0be7bcd22c1c8a25f4895ec760b34aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">関数の引数を読み込む  <a href="classNode.html#a0be7bcd22c1c8a25f4895ec760b34aa4">More...</a><br /></td></tr>
<tr class="separator:a0be7bcd22c1c8a25f4895ec760b34aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0cacb88f8fe961ac1306d002d045f4"><td class="memItemLeft" align="right" valign="top">static shared_ptr&lt; <a class="el" href="structMember.html">Member</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ada0cacb88f8fe961ac1306d002d045f4">get_struct_member</a> (<a class="el" href="classType.html">Type</a> *ty, <a class="el" href="classToken.html">Token</a> *token)</td></tr>
<tr class="memdesc:ada0cacb88f8fe961ac1306d002d045f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">入力トークンと対応する構造体のメンバーを取得する。 見つからなければエラーとする。  <a href="classNode.html#ada0cacb88f8fe961ac1306d002d045f4">More...</a><br /></td></tr>
<tr class="separator:ada0cacb88f8fe961ac1306d002d045f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99f2f930ba1241c48c5229cc461fc75"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classToken.html">Token</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aa99f2f930ba1241c48c5229cc461fc75">global_variable</a> (<a class="el" href="classToken.html">Token</a> *token, shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; &amp;&amp;base, const <a class="el" href="structObject_1_1VarAttr.html">Object::VarAttr</a> *attr)</td></tr>
<tr class="memdesc:aa99f2f930ba1241c48c5229cc461fc75"><td class="mdescLeft">&#160;</td><td class="mdescRight">グローバル変数を読み取る  <a href="classNode.html#aa99f2f930ba1241c48c5229cc461fc75">More...</a><br /></td></tr>
<tr class="separator:aa99f2f930ba1241c48c5229cc461fc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa046f1266f2e94ca03f6069c296c4298"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aa046f1266f2e94ca03f6069c296c4298">gvar_initializer</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token, <a class="el" href="classObject.html">Object</a> *var)</td></tr>
<tr class="memdesc:aa046f1266f2e94ca03f6069c296c4298"><td class="mdescLeft">&#160;</td><td class="mdescRight">グローバル変数の初期化式を生成する  <a href="classNode.html#aa046f1266f2e94ca03f6069c296c4298">More...</a><br /></td></tr>
<tr class="separator:aa046f1266f2e94ca03f6069c296c4298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7ff712f3d9b8d3e29b8d4191e2b715"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a5c7ff712f3d9b8d3e29b8d4191e2b715">init_desg_expr</a> (Object::Object::InitDesg *desg, <a class="el" href="classToken.html">Token</a> *token)</td></tr>
<tr class="memdesc:a5c7ff712f3d9b8d3e29b8d4191e2b715"><td class="mdescLeft">&#160;</td><td class="mdescRight">初期化式の代入先を再帰的に構成する  <a href="classNode.html#a5c7ff712f3d9b8d3e29b8d4191e2b715">More...</a><br /></td></tr>
<tr class="separator:a5c7ff712f3d9b8d3e29b8d4191e2b715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb63ecf931e132dc9fc7518c9941d73"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="structObject_1_1Initializer.html">Object::Initializer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aaeb63ecf931e132dc9fc7518c9941d73">initializer</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token, shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; ty, shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; &amp;new_ty)</td></tr>
<tr class="memdesc:aaeb63ecf931e132dc9fc7518c9941d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">変数の初期化式を読み取って生成する  <a href="classNode.html#aaeb63ecf931e132dc9fc7518c9941d73">More...</a><br /></td></tr>
<tr class="separator:aaeb63ecf931e132dc9fc7518c9941d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03466261131b1016aa894d08bc0ad254"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a03466261131b1016aa894d08bc0ad254">initializer2</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token, <a class="el" href="structObject_1_1Initializer.html">Object::Initializer</a> *init)</td></tr>
<tr class="memdesc:a03466261131b1016aa894d08bc0ad254"><td class="mdescLeft">&#160;</td><td class="mdescRight">最適的に初期化式の中身を読み取っていく  <a href="classNode.html#a03466261131b1016aa894d08bc0ad254">More...</a><br /></td></tr>
<tr class="separator:a03466261131b1016aa894d08bc0ad254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959a61dd6574069b0dcbb3fe1be5756b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a959a61dd6574069b0dcbb3fe1be5756b">is_function</a> (<a class="el" href="classToken.html">Token</a> *token)</td></tr>
<tr class="memdesc:a959a61dd6574069b0dcbb3fe1be5756b"><td class="mdescLeft">&#160;</td><td class="mdescRight">トップレベルに出てくる定義が関数かどうか判定する  <a href="classNode.html#a959a61dd6574069b0dcbb3fe1be5756b">More...</a><br /></td></tr>
<tr class="separator:a959a61dd6574069b0dcbb3fe1be5756b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15f6017270dae78039f56f35819e3b1"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad15f6017270dae78039f56f35819e3b1">log_and</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:ad15f6017270dae78039f56f35819e3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">log_andを読み取る  <a href="classNode.html#ad15f6017270dae78039f56f35819e3b1">More...</a><br /></td></tr>
<tr class="separator:ad15f6017270dae78039f56f35819e3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef7a185f61351a7f669f63b01f24c56"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a8ef7a185f61351a7f669f63b01f24c56">log_or</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:a8ef7a185f61351a7f669f63b01f24c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">log_orを読み取る  <a href="classNode.html#a8ef7a185f61351a7f669f63b01f24c56">More...</a><br /></td></tr>
<tr class="separator:a8ef7a185f61351a7f669f63b01f24c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac749df21e281318cd1cab00a3fa0b7df"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ac749df21e281318cd1cab00a3fa0b7df">lvar_initializer</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token, <a class="el" href="classObject.html">Object</a> *var)</td></tr>
<tr class="memdesc:ac749df21e281318cd1cab00a3fa0b7df"><td class="mdescLeft">&#160;</td><td class="mdescRight">ローカル変数の初期化式を読み取って生成する  <a href="classNode.html#ac749df21e281318cd1cab00a3fa0b7df">More...</a><br /></td></tr>
<tr class="separator:ac749df21e281318cd1cab00a3fa0b7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94633274125230db126333edf6050f5"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ab94633274125230db126333edf6050f5">mul</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:ab94633274125230db126333edf6050f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">積を読み取る。  <a href="classNode.html#ab94633274125230db126333edf6050f5">More...</a><br /></td></tr>
<tr class="separator:ab94633274125230db126333edf6050f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f3fe0d5cf5f66863117d742577d7a0"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a17f3fe0d5cf5f66863117d742577d7a0">new_add</a> (unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &amp;&amp;lhs, unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &amp;&amp;rhs, <a class="el" href="classToken.html">Token</a> *token)</td></tr>
<tr class="memdesc:a17f3fe0d5cf5f66863117d742577d7a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">左辺 + 右辺の計算結果を表すノードを生成する。  <a href="classNode.html#a17f3fe0d5cf5f66863117d742577d7a0">More...</a><br /></td></tr>
<tr class="separator:a17f3fe0d5cf5f66863117d742577d7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680528ca9cd05ed39074202b9e3a4c1a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classObject.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a680528ca9cd05ed39074202b9e3a4c1a">new_anonymous_gvar</a> (shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; &amp;ty)</td></tr>
<tr class="memdesc:a680528ca9cd05ed39074202b9e3a4c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">仮名を付けてグローバル変数を生成する  <a href="classNode.html#a680528ca9cd05ed39074202b9e3a4c1a">More...</a><br /></td></tr>
<tr class="separator:a680528ca9cd05ed39074202b9e3a4c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebfff0abcd7bbacf13b02e3b9ebcb95"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aaebfff0abcd7bbacf13b02e3b9ebcb95">new_inc_dec</a> (unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &amp;&amp;node, <a class="el" href="classToken.html">Token</a> *token, int addend)</td></tr>
<tr class="memdesc:aaebfff0abcd7bbacf13b02e3b9ebcb95"><td class="mdescLeft">&#160;</td><td class="mdescRight">後置++, &ndash;に対応するノードを生成する  <a href="classNode.html#aaebfff0abcd7bbacf13b02e3b9ebcb95">More...</a><br /></td></tr>
<tr class="separator:aaebfff0abcd7bbacf13b02e3b9ebcb95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927521bb6663e46e2f5fac7e868a3c39"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classObject.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a927521bb6663e46e2f5fac7e868a3c39">new_string_literal</a> (const string &amp;str)</td></tr>
<tr class="memdesc:a927521bb6663e46e2f5fac7e868a3c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">文字列リテラルとしてstrをもつグローバル変数を生成する。  <a href="classNode.html#a927521bb6663e46e2f5fac7e868a3c39">More...</a><br /></td></tr>
<tr class="separator:a927521bb6663e46e2f5fac7e868a3c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcde385f4cca27318b011517ec6800fd"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#afcde385f4cca27318b011517ec6800fd">new_sub</a> (unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &amp;&amp;lhs, unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &amp;&amp;rhs, <a class="el" href="classToken.html">Token</a> *token)</td></tr>
<tr class="memdesc:afcde385f4cca27318b011517ec6800fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">左辺 - 右辺の計算結果を表すノードを生成する。  <a href="classNode.html#afcde385f4cca27318b011517ec6800fd">More...</a><br /></td></tr>
<tr class="separator:afcde385f4cca27318b011517ec6800fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc883aab2870fb38a4ba2afdbdf84d2f"><td class="memItemLeft" align="right" valign="top">static string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#afc883aab2870fb38a4ba2afdbdf84d2f">new_unique_name</a> ()</td></tr>
<tr class="memdesc:afc883aab2870fb38a4ba2afdbdf84d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">グローバル変数の仮名としてユニークな名前を生成する  <a href="classNode.html#afc883aab2870fb38a4ba2afdbdf84d2f">More...</a><br /></td></tr>
<tr class="separator:afc883aab2870fb38a4ba2afdbdf84d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7c095dc129299f0a3be6e8f4ebd2cb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classToken.html">Token</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a3d7c095dc129299f0a3be6e8f4ebd2cb">parse_typedef</a> (<a class="el" href="classToken.html">Token</a> *token, shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; &amp;base)</td></tr>
<tr class="memdesc:a3d7c095dc129299f0a3be6e8f4ebd2cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">typedefを読み取る  <a href="classNode.html#a3d7c095dc129299f0a3be6e8f4ebd2cb">More...</a><br /></td></tr>
<tr class="separator:a3d7c095dc129299f0a3be6e8f4ebd2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82412593debe77ec2d5cd5674f86e65"><td class="memItemLeft" align="right" valign="top">static shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#af82412593debe77ec2d5cd5674f86e65">pointers</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token, shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; ty)</td></tr>
<tr class="memdesc:af82412593debe77ec2d5cd5674f86e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">ポインタ指定と型修飾子を読み取る  <a href="classNode.html#af82412593debe77ec2d5cd5674f86e65">More...</a><br /></td></tr>
<tr class="separator:af82412593debe77ec2d5cd5674f86e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02060599427d1a2118dc8b2c32a68b5"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aa02060599427d1a2118dc8b2c32a68b5">postfix</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:aa02060599427d1a2118dc8b2c32a68b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">型指定子の後に続くpostfixを読み取る  <a href="classNode.html#aa02060599427d1a2118dc8b2c32a68b5">More...</a><br /></td></tr>
<tr class="separator:aa02060599427d1a2118dc8b2c32a68b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809dc3715ea0d01684c6b6077830a6de"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a809dc3715ea0d01684c6b6077830a6de">primary</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:a809dc3715ea0d01684c6b6077830a6de"><td class="mdescLeft">&#160;</td><td class="mdescRight">単項を読み取る。  <a href="classNode.html#a809dc3715ea0d01684c6b6077830a6de">More...</a><br /></td></tr>
<tr class="separator:a809dc3715ea0d01684c6b6077830a6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018ced673106084fe950559f81452796"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a018ced673106084fe950559f81452796">relational</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:a018ced673106084fe950559f81452796"><td class="mdescLeft">&#160;</td><td class="mdescRight">比較式を読み取る。  <a href="classNode.html#a018ced673106084fe950559f81452796">More...</a><br /></td></tr>
<tr class="separator:a018ced673106084fe950559f81452796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677f7f88360eb4606499c48a2746dcb9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a677f7f88360eb4606499c48a2746dcb9">resolve_goto_label</a> ()</td></tr>
<tr class="memdesc:a677f7f88360eb4606499c48a2746dcb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">goto文とラベルの対応を解決する  <a href="classNode.html#a677f7f88360eb4606499c48a2746dcb9">More...</a><br /></td></tr>
<tr class="separator:a677f7f88360eb4606499c48a2746dcb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b27498887417b678e70768102e7a51"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ae9b27498887417b678e70768102e7a51">shift</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:ae9b27498887417b678e70768102e7a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">シフト演算子を読み取る  <a href="classNode.html#ae9b27498887417b678e70768102e7a51">More...</a><br /></td></tr>
<tr class="separator:ae9b27498887417b678e70768102e7a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45a8a1bb66144e5fefa657d2ef5cc98"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classToken.html">Token</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad45a8a1bb66144e5fefa657d2ef5cc98">skip</a> (<a class="el" href="classToken.html">Token</a> *token, string &amp;&amp;op)</td></tr>
<tr class="memdesc:ad45a8a1bb66144e5fefa657d2ef5cc98"><td class="mdescLeft">&#160;</td><td class="mdescRight">トークンが期待している文字列と一致する場合は次のトークンのポインタを返す。不一致ならエラー報告。  <a href="classNode.html#ad45a8a1bb66144e5fefa657d2ef5cc98">More...</a><br /></td></tr>
<tr class="separator:ad45a8a1bb66144e5fefa657d2ef5cc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb071b77e76070a869b318cea4eaed5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classToken.html">Token</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7bb071b77e76070a869b318cea4eaed5">skip_excess_element</a> (<a class="el" href="classToken.html">Token</a> *token)</td></tr>
<tr class="memdesc:a7bb071b77e76070a869b318cea4eaed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">余分な初期値を無視する。  <a href="classNode.html#a7bb071b77e76070a869b318cea4eaed5">More...</a><br /></td></tr>
<tr class="separator:a7bb071b77e76070a869b318cea4eaed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a21511a26ec7c7192c54948929e3867"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a2a21511a26ec7c7192c54948929e3867">statement</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:a2a21511a26ec7c7192c54948929e3867"><td class="mdescLeft">&#160;</td><td class="mdescRight">プログラム を読み取る。  <a href="classNode.html#a2a21511a26ec7c7192c54948929e3867">More...</a><br /></td></tr>
<tr class="separator:a2a21511a26ec7c7192c54948929e3867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b3198b0410e8e6bfe7196e08b5ace1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a08b3198b0410e8e6bfe7196e08b5ace1">string_initializer</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token, <a class="el" href="structObject_1_1Initializer.html">Object::Initializer</a> *init)</td></tr>
<tr class="memdesc:a08b3198b0410e8e6bfe7196e08b5ace1"><td class="mdescLeft">&#160;</td><td class="mdescRight">文字列型の変数の初期化式を生成する  <a href="classNode.html#a08b3198b0410e8e6bfe7196e08b5ace1">More...</a><br /></td></tr>
<tr class="separator:a08b3198b0410e8e6bfe7196e08b5ace1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692592775af7790d49eaf79e9388200e"><td class="memItemLeft" align="right" valign="top">static shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a692592775af7790d49eaf79e9388200e">struct_decl</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:a692592775af7790d49eaf79e9388200e"><td class="mdescLeft">&#160;</td><td class="mdescRight">構造体の宣言、定義を読み込む  <a href="classNode.html#a692592775af7790d49eaf79e9388200e">More...</a><br /></td></tr>
<tr class="separator:a692592775af7790d49eaf79e9388200e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dff2925e0c2325a873609a093bcbfb2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a1dff2925e0c2325a873609a093bcbfb2">struct_initializer1</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token, <a class="el" href="structObject_1_1Initializer.html">Object::Initializer</a> *init)</td></tr>
<tr class="memdesc:a1dff2925e0c2325a873609a093bcbfb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">構造体の変数の初期化式を生成する  <a href="classNode.html#a1dff2925e0c2325a873609a093bcbfb2">More...</a><br /></td></tr>
<tr class="separator:a1dff2925e0c2325a873609a093bcbfb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55930fe3333048b0d15da11252cc8d2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad55930fe3333048b0d15da11252cc8d2">struct_initializer2</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token, <a class="el" href="structObject_1_1Initializer.html">Object::Initializer</a> *init)</td></tr>
<tr class="memdesc:ad55930fe3333048b0d15da11252cc8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">構造体の変数の初期化式(前後に'{}'を持たない)を読み取り生成する  <a href="classNode.html#ad55930fe3333048b0d15da11252cc8d2">More...</a><br /></td></tr>
<tr class="separator:ad55930fe3333048b0d15da11252cc8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f212062f266ab855d4356f30a74273"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad9f212062f266ab855d4356f30a74273">struct_members</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token, <a class="el" href="classType.html">Type</a> *ty)</td></tr>
<tr class="memdesc:ad9f212062f266ab855d4356f30a74273"><td class="mdescLeft">&#160;</td><td class="mdescRight">構造体定義のメンバの定義を読み取る  <a href="classNode.html#ad9f212062f266ab855d4356f30a74273">More...</a><br /></td></tr>
<tr class="separator:ad9f212062f266ab855d4356f30a74273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f226a31ff83f09d97aaf3b7c058452"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a94f226a31ff83f09d97aaf3b7c058452">struct_ref</a> (unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &amp;&amp;lhs, <a class="el" href="classToken.html">Token</a> *token)</td></tr>
<tr class="memdesc:a94f226a31ff83f09d97aaf3b7c058452"><td class="mdescLeft">&#160;</td><td class="mdescRight">構造体,共用体のメンバにアクセスするノードを生成する  <a href="classNode.html#a94f226a31ff83f09d97aaf3b7c058452">More...</a><br /></td></tr>
<tr class="separator:a94f226a31ff83f09d97aaf3b7c058452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61804423873eafcd941fd45eab1c7f89"><td class="memItemLeft" align="right" valign="top">static shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a61804423873eafcd941fd45eab1c7f89">struct_union_decl</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:a61804423873eafcd941fd45eab1c7f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">構造体,共用体の宣言、定義を読み込む  <a href="classNode.html#a61804423873eafcd941fd45eab1c7f89">More...</a><br /></td></tr>
<tr class="separator:a61804423873eafcd941fd45eab1c7f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827708315ba6c87e7d344683228bc8bd"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a827708315ba6c87e7d344683228bc8bd">to_assign</a> (unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &amp;&amp;binary)</td></tr>
<tr class="memdesc:a827708315ba6c87e7d344683228bc8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">演算代入式を表すノードを生成する  <a href="classNode.html#a827708315ba6c87e7d344683228bc8bd">More...</a><br /></td></tr>
<tr class="separator:a827708315ba6c87e7d344683228bc8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c663224a5dc1847c9934dfebd230c9"><td class="memItemLeft" align="right" valign="top">static shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a84c663224a5dc1847c9934dfebd230c9">type_name</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:a84c663224a5dc1847c9934dfebd230c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">型情報を読み取る  <a href="classNode.html#a84c663224a5dc1847c9934dfebd230c9">More...</a><br /></td></tr>
<tr class="separator:a84c663224a5dc1847c9934dfebd230c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf4dcff0f0d7730933637dd16decb25"><td class="memItemLeft" align="right" valign="top">static shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#afcf4dcff0f0d7730933637dd16decb25">type_suffix</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token, shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; &amp;&amp;ty)</td></tr>
<tr class="memdesc:afcf4dcff0f0d7730933637dd16decb25"><td class="mdescLeft">&#160;</td><td class="mdescRight">宣言を変数 or 関数か判断し結果の型を返す  <a href="classNode.html#afcf4dcff0f0d7730933637dd16decb25">More...</a><br /></td></tr>
<tr class="separator:afcf4dcff0f0d7730933637dd16decb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61be0c6d6aa6bbbb27c220a3ec18456f"><td class="memItemLeft" align="right" valign="top">static unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a61be0c6d6aa6bbbb27c220a3ec18456f">unary</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:a61be0c6d6aa6bbbb27c220a3ec18456f"><td class="mdescLeft">&#160;</td><td class="mdescRight">符号付の単項を読み取る。  <a href="classNode.html#a61be0c6d6aa6bbbb27c220a3ec18456f">More...</a><br /></td></tr>
<tr class="separator:a61be0c6d6aa6bbbb27c220a3ec18456f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fbae277939be92f332caafacdc6a50"><td class="memItemLeft" align="right" valign="top">static shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aa2fbae277939be92f332caafacdc6a50">union_decl</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token)</td></tr>
<tr class="memdesc:aa2fbae277939be92f332caafacdc6a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">共用体の宣言、定義を読み込む  <a href="classNode.html#aa2fbae277939be92f332caafacdc6a50">More...</a><br /></td></tr>
<tr class="separator:aa2fbae277939be92f332caafacdc6a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05efdbd49d1642d2a93bc3654e338a7e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a05efdbd49d1642d2a93bc3654e338a7e">union_initializer</a> (<a class="el" href="classToken.html">Token</a> **next_token, <a class="el" href="classToken.html">Token</a> *current_token, <a class="el" href="structObject_1_1Initializer.html">Object::Initializer</a> *init)</td></tr>
<tr class="memdesc:a05efdbd49d1642d2a93bc3654e338a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">共用体の変数の初期化式を生成する。共用体は1要素しか初期化式をもたない。  <a href="classNode.html#a05efdbd49d1642d2a93bc3654e338a7e">More...</a><br /></td></tr>
<tr class="separator:a05efdbd49d1642d2a93bc3654e338a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49dbdf23f45f361e93abca72dff4e3fe"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a49dbdf23f45f361e93abca72dff4e3fe">write_buf</a> (unsigned char buf[], int64_t val, int sz, int offset)</td></tr>
<tr class="memdesc:a49dbdf23f45f361e93abca72dff4e3fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">整数valの内部表現を1バイトずつbuf[offset]に書き込む  <a href="classNode.html#a49dbdf23f45f361e93abca72dff4e3fe">More...</a><br /></td></tr>
<tr class="separator:a49dbdf23f45f361e93abca72dff4e3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47e5c8d5ae1268077bf65b6ce450b4d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ae47e5c8d5ae1268077bf65b6ce450b4d">write_fval_buf</a> (unsigned char buf[], double val, int sz, int offset)</td></tr>
<tr class="memdesc:ae47e5c8d5ae1268077bf65b6ce450b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">浮動小数点数valの内部表現を1バイトずつbuf[offset]に書き込む  <a href="classNode.html#ae47e5c8d5ae1268077bf65b6ce450b4d">More...</a><br /></td></tr>
<tr class="separator:ae47e5c8d5ae1268077bf65b6ce450b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392113c6b92c9bb62f05805b360e70c0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structObject_1_1Relocation.html">Object::Relocation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a392113c6b92c9bb62f05805b360e70c0">write_gvar_data</a> (<a class="el" href="structObject_1_1Relocation.html">Object::Relocation</a> *cur, <a class="el" href="structObject_1_1Initializer.html">Object::Initializer</a> *init, <a class="el" href="classType.html">Type</a> *ty, unsigned char buf[], int offset)</td></tr>
<tr class="memdesc:a392113c6b92c9bb62f05805b360e70c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">グローバル変数の初期化データを生成する  <a href="classNode.html#a392113c6b92c9bb62f05805b360e70c0">More...</a><br /></td></tr>
<tr class="separator:a392113c6b92c9bb62f05805b360e70c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>抽象構文木(AST)を構成するノード </p>

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00088">88</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad7a34779cad45d997bfd6d3d8043c75f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a34779cad45d997bfd6d3d8043c75f">&#9670;&nbsp;</a></span>Node() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Node::Node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e0cd7b0188c6e9e93dfcfa3e3c19947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e0cd7b0188c6e9e93dfcfa3e3c19947">&#9670;&nbsp;</a></span>Node() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Node::Node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="parse_8hpp.html#adaa4ecec941fa446d7019c24371f4ff0">NodeKind</a> &amp;&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00042">42</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a675d820589eb5f44ebe6a89a155dd9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675d820589eb5f44ebe6a89a155dd9e1">&#9670;&nbsp;</a></span>Node() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Node::Node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="parse_8hpp.html#adaa4ecec941fa446d7019c24371f4ff0">NodeKind</a> &amp;&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00044">44</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a83405d72fc70460afc3a5c88e35f5115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83405d72fc70460afc3a5c88e35f5115">&#9670;&nbsp;</a></span>Node() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Node::Node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="parse_8hpp.html#adaa4ecec941fa446d7019c24371f4ff0">NodeKind</a> &amp;&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00047">47</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a4d16b6ca1a91a8467542932eff00d1ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d16b6ca1a91a8467542932eff00d1ca">&#9670;&nbsp;</a></span>Node() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Node::Node </td>
          <td>(</td>
          <td class="paramtype">const int64_t &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00050">50</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="ad0ab0694366f91241d1c6e58c2ec047a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ab0694366f91241d1c6e58c2ec047a">&#9670;&nbsp;</a></span>Node() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Node::Node </td>
          <td>(</td>
          <td class="paramtype">const int64_t &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00053">53</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a583c3f3c759c6da54635c704660de8f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583c3f3c759c6da54635c704660de8f6">&#9670;&nbsp;</a></span>Node() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Node::Node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classObject.html">Object</a> *&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00056">56</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a711ba9a5637db4998690ae582ceb5d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711ba9a5637db4998690ae582ceb5d13">&#9670;&nbsp;</a></span>abstract_declarator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; Node::abstract_declarator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt;&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>識別子をもたない仮想的な変数宣言として型情報を読む </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
    <tr><td class="paramname">ty</td><td>型指定子の型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>読み取った型</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
 abstract-declarator = "*"* ("(" abstract-declarator ")")? type-suffix </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l03318">3318</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a5dd2be583a80290629b0a1cce615292c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd2be583a80290629b0a1cce615292c">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>和を読み取る。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>対応するASTノード</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
 add = mul ("+" mul | "-" mul)* </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l02854">2854</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a6cd897b0cd52768efa5621d71ab642b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd897b0cd52768efa5621d71ab642b5">&#9670;&nbsp;</a></span>array_dimensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; Node::array_dimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>配列の宣言の要素数部分を読み取る </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
    <tr><td class="paramname">ty</td><td>宣言されている型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>配列の型</dd></dl>
<p>次のEBNF規則に従う。 <br  />
 array-dimensions = ("static" | "restrict")* const-expr? "]" type-suffix </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l01516">1516</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="accf43dab749eb23892af07c8d0021a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf43dab749eb23892af07c8d0021a04">&#9670;&nbsp;</a></span>array_initializer1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::array_initializer1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structObject_1_1Initializer.html">Object::Initializer</a> *&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>配列の変数の初期化式（前後に'{}'を持つ）を読み取りを生成する </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
    <tr><td class="paramname">init</td><td>初期化式</td></tr>
  </table>
  </dd>
</dl>
<p>以下のEBNF規則に従う。 <br  />
array_initializer1 = "{" identifier ("," identifier)* ","? "}" </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l01009">1009</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="af1d01120505dd287c49a3a3337c3fcb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d01120505dd287c49a3a3337c3fcb0">&#9670;&nbsp;</a></span>array_initializer2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::array_initializer2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structObject_1_1Initializer.html">Object::Initializer</a> *&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>配列の変数の初期化式（前後に'{}'を持たない）を読み取り生成する </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
    <tr><td class="paramname">init</td><td>初期化式</td></tr>
  </table>
  </dd>
</dl>
<p>以下のEBNF規則に従う。 <br  />
array_initializer2 = identifier ("," identifier)* </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l01048">1048</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a1d2dd105cfe60d02d1f498d0f18018c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2dd105cfe60d02d1f498d0f18018c8">&#9670;&nbsp;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>代入式を読み取る。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>対応するASTノード</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
assign = conditional (assign-op assign)? <br  />
assign-op = "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&lt;&lt;=" | "&gt;&gt;=" </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l02553">2553</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="aa81f434d44279957730ec41ab67d7b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81f434d44279957730ec41ab67d7b87">&#9670;&nbsp;</a></span>bit_and()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::bit_and </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bitandを読み取る </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>対応するASTノード</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
 bitand = equality ("&amp;" equality)* </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l02714">2714</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="aebc27fa3fe69dd8fc47e66a36df6cdfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc27fa3fe69dd8fc47e66a36df6cdfd">&#9670;&nbsp;</a></span>bit_or()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::bit_or </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bitorを読み取る </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>対応するASTノード</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
 bitor = bitxor ("|" bitxor)* </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l02671">2671</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="afe7f379d42f3bb4568077ac9d93a6c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7f379d42f3bb4568077ac9d93a6c5a">&#9670;&nbsp;</a></span>bit_xor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::bit_xor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bitxorを読み取る </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>対応するASTノード</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
 bitxor = bitand ("^" bitand)* </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l02693">2693</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="abf4a318b37151b2cd242f99372409a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4a318b37151b2cd242f99372409a06">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>型キャストを読み取る </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>対応するASTノード</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
 "(" type-name ")" cast | unary </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l02887">2887</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="ad2edbb5288a0563b4f25774e1a6da24b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2edbb5288a0563b4f25774e1a6da24b">&#9670;&nbsp;</a></span>compound_statement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::compound_statement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ブロックを読み取る。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>対応するASTノード</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
 compound-statement = (typedef | declaration | statement)* "}" </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00600">600</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a7d35e180a973cee8500708170ea649e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d35e180a973cee8500708170ea649e9">&#9670;&nbsp;</a></span>conditional()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::conditional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>3項演算子を読み取る </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>対応するASTノード</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
 conditional = logor ( "?" expr ":" conditional )? </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l02600">2600</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="ae11ea1ada6e842418ef5ba9ac54e15ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11ea1ada6e842418ef5ba9ac54e15ae">&#9670;&nbsp;</a></span>const_expr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t Node::const_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>定数式を読み取って評価する </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>評価結果の数値 </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l02501">2501</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a921691ddfc78486a50249c98479c8eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a921691ddfc78486a50249c98479c8eda">&#9670;&nbsp;</a></span>consume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::consume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>トークンが期待している文字列と一致する場合は次のトークンのポインタをnext_tokenにセットしtrueを返す。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
    <tr><td class="paramname">op</td><td>比較する文字列 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一致：true, 不一致：false </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l03549">3549</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a5e4e5a2b07bde70878d5ee19bf2cc338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4e5a2b07bde70878d5ee19bf2cc338">&#9670;&nbsp;</a></span>consume_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::consume_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>トークンが配列、構造体、列挙型の末尾と一致する場合は次のトークンのポインタをnext_tokenにセットしtrueを返す。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一致：true, 不一致：false </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l03583">3583</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="ab3d898facee3b78ab884be4079e6e11f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d898facee3b78ab884be4079e6e11f">&#9670;&nbsp;</a></span>count_array_init_element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Node::count_array_init_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>初期化式で与えられた配列の要素数を数える </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>現在のトークン </td></tr>
    <tr><td class="paramname">ty</td><td>配列の型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>配列の要素数 </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00983">983</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="ac907c167a672a4d0eb7d8b5118524884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac907c167a672a4d0eb7d8b5118524884">&#9670;&nbsp;</a></span>create_lvar_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::create_lvar_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structObject_1_1Initializer.html">Object::Initializer</a> *&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structObject_1_1InitDesg.html">Object::InitDesg</a> *&#160;</td>
          <td class="paramname"><em>desg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ローカル変数を初期化するノードを構成する。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>初期化式 </td></tr>
    <tr><td class="paramname">ty</td><td>変数の型 </td></tr>
    <tr><td class="paramname">desg</td><td>変数の中で現在ノードを作成している位置 </td></tr>
    <tr><td class="paramname">token</td><td>ノードと対応するトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>生成したノード </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l01208">1208</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="ad583c276c7388fc2599e67cddd05afb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad583c276c7388fc2599e67cddd05afb0">&#9670;&nbsp;</a></span>declaration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::declaration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structObject_1_1VarAttr.html">Object::VarAttr</a> *&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>変数宣言を読み取る </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>対応するASTノード</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
 declaration = declspec (declarator ("=" expr)? ("," declarator ("=" expr)?)*)? ";" </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00749">749</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="ab6bdde7ae2632ef8b8f24a451c1deb35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6bdde7ae2632ef8b8f24a451c1deb35">&#9670;&nbsp;</a></span>declarator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; Node::declarator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt;&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>変数宣言を変数名部分を読み取る </p>
<p>変数の型は変数名に辿りつくまで確定できない。 <br  />
例：int a, *b, **c; aはint型、bはint型へのポインタ、cはint型へのポインタへのポインタ <br  />
下記のEBNF規則に従う。 <br  />
 declarator = pointers ("(" identifier ")" | "(" declarator ")" | identifier) type-suffix </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
    <tr><td class="paramname">ty</td><td>変数の型の基準 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>変数の型 </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l01581">1581</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="af4bd952f89bd71a593c7be358710dc17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4bd952f89bd71a593c7be358710dc17">&#9670;&nbsp;</a></span>declspec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; Node::declspec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structObject_1_1VarAttr.html">Object::VarAttr</a> *&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>変数宣言の型指定子部分を読み取る </p>
<p>下記のEBNF規則に従う。 <br  />
declspec = ("void" | "_BOOL" | "int" | "short" | "long" | "char" <br  />
 | "typedef" | "static" | "extern" <br  />
 | "signed" <br  />
 | struct-decl | union-decl | typedef-name <br  />
 | enum-specifier)+ <br  />
 | "const" | "volatile" | "auto" | "register" | "restrict" <br  />
 | "__restrict" | "__restrict__" | "_Noreturn")+ <br  />
型指定子における型名の順番は重要ではない。例えば、<code>int long static</code> は <code>static long int</code> と同じ意味である。 'long<code>や</code>short<code>が指定されていれば</code>int<code>を省略できるので、</code>static long<code>と書くこともできる。 しかし、</code>char int` のようなものは有効な型指定子ではなく、型名の組み合わせは限られている。 この関数では、それまでの型名が表す「現在の」型オブジェクトを保持したまま、各型名の出現回数を数える。 型名でないトークンに達すると、現在の型オブジェクトを返す。</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
    <tr><td class="paramname">attr</td><td>読み取った型の属性を返すための参照 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>変数の型 </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l01888">1888</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a0d0085e6c1eef10b0740e264b0ca499d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0085e6c1eef10b0740e264b0ca499d">&#9670;&nbsp;</a></span>enum_specifier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; Node::enum_specifier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>列挙型の定義を読み取る </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>対応する列挙型の型</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
enum-specifier = ident? "{" enum-list? "}" | ident ("{" enum-list? "}")? <br  />
enum-list = ident ("=" const-expr)? ("," ident ("=" const-expr)?)* ","? </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l02095">2095</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a9bd15962749cca28595bcb2f20216754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd15962749cca28595bcb2f20216754">&#9670;&nbsp;</a></span>equality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::equality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>等価比較式を読み取る。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>対応するASTノード</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
 equality = relational ("==" relational | "!=" relational)* </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l02735">2735</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a5f7dc39f4f7460140c7b02b1176866a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7dc39f4f7460140c7b02b1176866a3">&#9670;&nbsp;</a></span>evaluate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t Node::evaluate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ノードを定数式として評価 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>評価するノード </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>評価結果の数値 </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l02213">2213</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="aeebda070fc170dec37c8925b8eb97ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeebda070fc170dec37c8925b8eb97ff9">&#9670;&nbsp;</a></span>evaluate2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t Node::evaluate2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ノードを定数式として評価 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>評価するノード </td></tr>
    <tr><td class="paramname">label</td><td>定数式が変数のポインタの場合、変数の名前 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>評価結果の数値 </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l02225">2225</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="ada84360a6ff9780fa4288fa01d123f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada84360a6ff9780fa4288fa01d123f1d">&#9670;&nbsp;</a></span>evaluate_double()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Node::evaluate_double </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>浮動小数点数型の定数式を評価する </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">評価対象のノード</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>評価結果 </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l02405">2405</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="ac7296778f03309fd44641a17da72cb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7296778f03309fd44641a17da72cb24">&#9670;&nbsp;</a></span>evaluate_rval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t Node::evaluate_rval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>右辺値を評価する </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>評価対象のノード </td></tr>
    <tr><td class="paramname">label</td><td>変数名を返すための参照 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>評価結果 </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l02469">2469</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a0c70f89b4f82254629ac6de91c0c6585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c70f89b4f82254629ac6de91c0c6585">&#9670;&nbsp;</a></span>expression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::expression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>式を読み取る。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>対応するASTノード</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
 expression = assign (',' expression)? </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l02194">2194</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a82c1b8db1299932bf2536db15c69deec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c1b8db1299932bf2536db15c69deec">&#9670;&nbsp;</a></span>expression_statement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::expression_statement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>単文を読み取る。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>対応するASTノード</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
 expression-statement = expression? ';' </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l02170">2170</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a98c338e28cdf77942c664dadf4895f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c338e28cdf77942c664dadf4895f30">&#9670;&nbsp;</a></span>function_call()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::function_call </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>関数呼び出し </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>対応するASTノード</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
function_call = "(" (assign ("," assign)*)? ")" </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l03362">3362</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a92291df4f4c17be9db9c8aa69179f236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92291df4f4c17be9db9c8aa69179f236">&#9670;&nbsp;</a></span>function_definition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classToken.html">Token</a> * Node::function_definition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structObject_1_1VarAttr.html">Object::VarAttr</a> *&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>関数宣言、定義を読み取る。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>現在処理しているトークン </td></tr>
    <tr><td class="paramname">base</td><td>関数の戻り値の型のベース </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>次のトークン</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
 function-definition = declarator ( "{" compound-statement | ";" ) </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00673">673</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a0be7bcd22c1c8a25f4895ec760b34aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be7bcd22c1c8a25f4895ec760b34aa4">&#9670;&nbsp;</a></span>function_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; Node::function_parameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>関数の引数を読み込む </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
    <tr><td class="paramname">ty</td><td>宣言されている型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>引数の情報を含む関数の型</dd></dl>
<p>以下のEBNF規則に従う。 <br  />
function-parameters = ( "void" | parameters ("," parameters)* ("," "...")?)? ")" <br  />
parameters = declspec declarator </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l01442">1442</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="ada0cacb88f8fe961ac1306d002d045f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0cacb88f8fe961ac1306d002d045f4">&#9670;&nbsp;</a></span>get_struct_member()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; <a class="el" href="structMember.html">Member</a> &gt; Node::get_struct_member </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>入力トークンと対応する構造体のメンバーを取得する。 見つからなければエラーとする。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ty</td><td>構造体の型情報 </td></tr>
    <tr><td class="paramname">token</td><td>取得するメンバのトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>構造体のメンバのポインタ </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l01824">1824</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="aa99f2f930ba1241c48c5229cc461fc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99f2f930ba1241c48c5229cc461fc75">&#9670;&nbsp;</a></span>global_variable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classToken.html">Token</a> * Node::global_variable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structObject_1_1VarAttr.html">Object::VarAttr</a> *&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>グローバル変数を読み取る </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>読み込むトークン </td></tr>
    <tr><td class="paramname">base</td><td>型宣言の前半部分から読み取れた型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>次のトークン </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l03468">3468</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="aa046f1266f2e94ca03f6069c296c4298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa046f1266f2e94ca03f6069c296c4298">&#9670;&nbsp;</a></span>gvar_initializer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::gvar_initializer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classObject.html">Object</a> *&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>グローバル変数の初期化式を生成する </p>
<p>グローバル変数の初期化式はコンパイル時に評価され、.dataセクションに配置される。 この関数では初期化式オブジェクトをバイト単位の配列に変換する。コンパイル時に 定数式ではない式を含む場合エラーとする。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td></td></tr>
    <tr><td class="paramname">current_token</td><td></td></tr>
    <tr><td class="paramname">var</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unique_ptr&lt;Node&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l01420">1420</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a5c7ff712f3d9b8d3e29b8d4191e2b715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7ff712f3d9b8d3e29b8d4191e2b715">&#9670;&nbsp;</a></span>init_desg_expr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::init_desg_expr </td>
          <td>(</td>
          <td class="paramtype">Object::Object::InitDesg *&#160;</td>
          <td class="paramname"><em>desg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>初期化式の代入先を再帰的に構成する </p>
<p>例 x[2][2] ={{..},{..}};という初期化式は *(*(x+i)+j) = v;(i =0,1, j=0,1)という形に変換される。 このときの左辺の代入先を表すノードを生成して返す</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desg</td><td>変数の中で現在ノードを作成している位置 </td></tr>
    <tr><td class="paramname">token</td><td>ノードと対応するトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>生成したノード </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l01179">1179</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="aaeb63ecf931e132dc9fc7518c9941d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb63ecf931e132dc9fc7518c9941d73">&#9670;&nbsp;</a></span>initializer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="structObject_1_1Initializer.html">Object::Initializer</a> &gt; Node::initializer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt;&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>変数の初期化式を読み取って生成する </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
    <tr><td class="paramname">ty</td><td>変数の型 </td></tr>
    <tr><td class="paramname">new_ty</td><td>初期化式から補完した完全な型を返すための参照 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>生成した初期化式 </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00844">844</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a03466261131b1016aa894d08bc0ad254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03466261131b1016aa894d08bc0ad254">&#9670;&nbsp;</a></span>initializer2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::initializer2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structObject_1_1Initializer.html">Object::Initializer</a> *&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>最適的に初期化式の中身を読み取っていく </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
    <tr><td class="paramname">現在、処理している初期化式</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>以下のEBNF規則に従う。 <br  />
initializer = string-initialize | array-initializer | struct-initializer | union-initializer |assign </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00883">883</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a959a61dd6574069b0dcbb3fe1be5756b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a959a61dd6574069b0dcbb3fe1be5756b">&#9670;&nbsp;</a></span>is_function()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::is_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>トップレベルに出てくる定義が関数かどうか判定する </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>declarator部分のトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true 関数である </dd>
<dd>
false 関数ではない </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l03449">3449</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="ad15f6017270dae78039f56f35819e3b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15f6017270dae78039f56f35819e3b1">&#9670;&nbsp;</a></span>log_and()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::log_and </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>log_andを読み取る </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>対応するASTノード</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
 logand = bitor ("&amp;&amp;" bitor)* </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l02649">2649</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a8ef7a185f61351a7f669f63b01f24c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef7a185f61351a7f669f63b01f24c56">&#9670;&nbsp;</a></span>log_or()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::log_or </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>log_orを読み取る </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>対応するASTノード</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
 logor = logand ("||" logand)* </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l02627">2627</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="ac749df21e281318cd1cab00a3fa0b7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac749df21e281318cd1cab00a3fa0b7df">&#9670;&nbsp;</a></span>lvar_initializer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::lvar_initializer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classObject.html">Object</a> *&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ローカル変数の初期化式を読み取って生成する </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
    <tr><td class="paramname">obj</td><td>変数を表すオブジェクト </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>対応するASTノード</dd></dl>
<p>初期化式が与えられなかった場合、各要素は0にセットする。 最初に変数に与えられたメモリ領域全体を0クリアしてその後に ユーザーが指定した初期値があれば設定する。 </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l01264">1264</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="ab94633274125230db126333edf6050f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94633274125230db126333edf6050f5">&#9670;&nbsp;</a></span>mul()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>積を読み取る。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>対応するASTノード</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
 mul = cast ("*" cast | "/" cast | "%" cast)* </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l02921">2921</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a17f3fe0d5cf5f66863117d742577d7a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17f3fe0d5cf5f66863117d742577d7a0">&#9670;&nbsp;</a></span>new_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::new_add </td>
          <td>(</td>
          <td class="paramtype">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>左辺 + 右辺の計算結果を表すノードを生成する。 </p>
<p>C言語では、+演算子はポインタ演算を行うためにオーバーロードされている。 もしpがポインタである場合、p+nはnを加えるのではなく、sizeof(*p)*nをpの値に加える。 そのため、p+nはpからn個先の要素（バイトではなく）を指すようになる。 言い換えれば、ポインタ値に加える前に整数値をスケールする必要があり、この関数はそのスケーリングを処理する。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>左辺 </td></tr>
    <tr><td class="paramname">rhs</td><td>右辺 </td></tr>
    <tr><td class="paramname">token</td><td>ノードと対応するトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>対応するASTノード </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00088">88</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a680528ca9cd05ed39074202b9e3a4c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680528ca9cd05ed39074202b9e3a4c1a">&#9670;&nbsp;</a></span>new_anonymous_gvar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classObject.html">Object</a> * Node::new_anonymous_gvar </td>
          <td>(</td>
          <td class="paramtype">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>仮名を付けてグローバル変数を生成する </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ty</td><td>生成するグローバル変数の型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unique_ptr&lt;Object&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00182">182</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a263d7bc3fbe5f8ddd49462e23dbf0ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263d7bc3fbe5f8ddd49462e23dbf0ae4">&#9670;&nbsp;</a></span>new_cast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::new_cast </td>
          <td>(</td>
          <td class="paramtype">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>型キャストに対応するノードを作成する </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>型キャストの対象とする式 </td></tr>
    <tr><td class="paramname">ty</td><td>キャスト後の型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unique_ptr&lt;Node&gt; 型キャストに対応するノード </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00065">65</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="aaebfff0abcd7bbacf13b02e3b9ebcb95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaebfff0abcd7bbacf13b02e3b9ebcb95">&#9670;&nbsp;</a></span>new_inc_dec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::new_inc_dec </td>
          <td>(</td>
          <td class="paramtype">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>後置++, &ndash;に対応するノードを生成する </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>インクリメント/デクリメントの対象ノード </td></tr>
    <tr><td class="paramname">token</td><td>ノードに対応するトークン </td></tr>
    <tr><td class="paramname">addend</td><td>インクリメントかデクリメントか </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>後置++, &ndash;に対応するノード</dd></dl>
<p>'A++'を'(typeof A)((A += 1) - 1)'と読み替える </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00223">223</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a927521bb6663e46e2f5fac7e868a3c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a927521bb6663e46e2f5fac7e868a3c39">&#9670;&nbsp;</a></span>new_string_literal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classObject.html">Object</a> * Node::new_string_literal </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>文字列リテラルとしてstrをもつグローバル変数を生成する。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>文字列リテラル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>生成したグローバル変数オブジェクトへのポインタ </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00193">193</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="afcde385f4cca27318b011517ec6800fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcde385f4cca27318b011517ec6800fd">&#9670;&nbsp;</a></span>new_sub()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::new_sub </td>
          <td>(</td>
          <td class="paramtype">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>左辺 - 右辺の計算結果を表すノードを生成する。 </p>
<p>C言語では、-演算子も'+'演算子と同様にポインタ演算を行うためにオーバーロードされている。 ポインタ - ポインタは2つのポインタ間にある要素の数を返す。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>左辺 </td></tr>
    <tr><td class="paramname">rhs</td><td>右辺 </td></tr>
    <tr><td class="paramname">token</td><td>ノードと対応するトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>対応するASTノード </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00128">128</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="afc883aab2870fb38a4ba2afdbdf84d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc883aab2870fb38a4ba2afdbdf84d2f">&#9670;&nbsp;</a></span>new_unique_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string Node::new_unique_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>グローバル変数の仮名としてユニークな名前を生成する </p>
<dl class="section return"><dt>Returns</dt><dd>生成した名前。".L..id"となる。(idは生成順) </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00170">170</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a8828892e50da48890283a6ddce025ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8828892e50da48890283a6ddce025ade">&#9670;&nbsp;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classObject.html">Object</a> &gt; Node::parse </td>
          <td>(</td>
          <td class="paramtype">const unique_ptr&lt; <a class="el" href="classToken.html">Token</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>トークン・リストを構文解析して関数ごとにASTを構築する </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>トークン・リスト </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>構文解析結果</dd></dl>
<p>program = (typedef | function-definition | global-variable)* </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00242">242</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a3d7c095dc129299f0a3be6e8f4ebd2cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7c095dc129299f0a3be6e8f4ebd2cb">&#9670;&nbsp;</a></span>parse_typedef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classToken.html">Token</a> * Node::parse_typedef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>typedefを読み取る </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>現在のトークン </td></tr>
    <tr><td class="paramname">base</td><td>ベースの型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>次のトークン </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l03255">3255</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="af82412593debe77ec2d5cd5674f86e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82412593debe77ec2d5cd5674f86e65">&#9670;&nbsp;</a></span>pointers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; Node::pointers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt;&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ポインタ指定と型修飾子を読み取る </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
    <tr><td class="paramname">ty</td><td>型指定子の型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>読み取った型</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
 pointers = ("*" ("const" | "volatile" | "restrict")*)* </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l03290">3290</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="aa02060599427d1a2118dc8b2c32a68b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa02060599427d1a2118dc8b2c32a68b5">&#9670;&nbsp;</a></span>postfix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::postfix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>型指定子の後に続くpostfixを読み取る </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>対応するASTノード</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
postfix = "(" type-name ")" "{" initializer-list "}" <br  />
 | identifier "(" func-args ")" postfix-tail* <br  />
 | primary postfix-tail* <br  />
postfix-tail = "[" expression "]" | "(" func-args ")" | "." identifier | "-&gt;" identifier | "++" | "--" </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l03013">3013</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a809dc3715ea0d01684c6b6077830a6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a809dc3715ea0d01684c6b6077830a6de">&#9670;&nbsp;</a></span>primary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::primary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>単項を読み取る。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>対応するASTノード</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
primary = "(" "{" statement+ "}" ")" | "(" expression ")" | "sizeof" unary | "sizeof" "(" type-name ")" <br  />
 | "_Alignof" "(" type-name ")" | "_Alignof" unary | identifier args? | str | num <br  />
 | args = "(" ")" | identifier | "__builtin_reg_class" "(" type-name ")" </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l03107">3107</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a018ced673106084fe950559f81452796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018ced673106084fe950559f81452796">&#9670;&nbsp;</a></span>relational()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::relational </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>比較式を読み取る。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>対応するASTノード</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
 relational = shift ("&lt;" shift | "&lt;=" shift | "&gt;" shift | "&gt;=" shift)* </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l02768">2768</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a677f7f88360eb4606499c48a2746dcb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677f7f88360eb4606499c48a2746dcb9">&#9670;&nbsp;</a></span>resolve_goto_label()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::resolve_goto_label </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>goto文とラベルの対応を解決する </p>
<p>goto文では現在の位置よりも後に出てくるラベルに ジャンプすることが可能なため、関数全体をパースした後でなければ ラベルとの対応を解決できない。 </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l03519">3519</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="ae9b27498887417b678e70768102e7a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b27498887417b678e70768102e7a51">&#9670;&nbsp;</a></span>shift()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>シフト演算子を読み取る </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>対応するASTノード</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
 shift = add ("&lt;&lt;" add | "&gt;&gt;" add)* </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l02816">2816</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="ad45a8a1bb66144e5fefa657d2ef5cc98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45a8a1bb66144e5fefa657d2ef5cc98">&#9670;&nbsp;</a></span>skip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classToken.html">Token</a> * Node::skip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>トークンが期待している文字列と一致する場合は次のトークンのポインタを返す。不一致ならエラー報告。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>対象のトークン </td></tr>
    <tr><td class="paramname">op</td><td>比較する文字列 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>次のトークン </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l03567">3567</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a7bb071b77e76070a869b318cea4eaed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb071b77e76070a869b318cea4eaed5">&#9670;&nbsp;</a></span>skip_excess_element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classToken.html">Token</a> * Node::skip_excess_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>余分な初期値を無視する。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>現在のトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>次のトークン </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l01157">1157</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a2a21511a26ec7c7192c54948929e3867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a21511a26ec7c7192c54948929e3867">&#9670;&nbsp;</a></span>statement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::statement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>プログラム を読み取る。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>対応するASTノード </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNode.html#a0c70f89b4f82254629ac6de91c0c6585" title="式を読み取る。">expression</a> compound-statement expression-statement</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
statement = "return" expression? ";" <br  />
 | "if" "(" expression ")" statement ("else" statement)? <br  />
 | "switch" "(" expression ")" statement <br  />
 | "case" const-expr ":" statement <br  />
 | "default" ":" statement <br  />
 | "for" "(" expression-statement expression? ";" expression? ")" statement <br  />
 | "while" "(" expression ")" statement <br  />
 | "do" statement "while" "(" expression ")" ";" <br  />
 | "goto" ident ";" <br  />
 | "continue" ";" <br  />
 | ident ":" statement <br  />
 | "{" compound-statement <br  />
 | expression-statement </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00296">296</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a08b3198b0410e8e6bfe7196e08b5ace1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b3198b0410e8e6bfe7196e08b5ace1">&#9670;&nbsp;</a></span>string_initializer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::string_initializer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structObject_1_1Initializer.html">Object::Initializer</a> *&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>文字列型の変数の初期化式を生成する </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
    <tr><td class="paramname">init</td><td>初期化式</td></tr>
  </table>
  </dd>
</dl>
<p>以下のEBNF規則に従う。 <br  />
string_initializer = string-literal </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00955">955</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a692592775af7790d49eaf79e9388200e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692592775af7790d49eaf79e9388200e">&#9670;&nbsp;</a></span>struct_decl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; Node::struct_decl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>構造体の宣言、定義を読み込む </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>構造体の型</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
 struct-decl = struct-union-decl </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l01687">1687</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a1dff2925e0c2325a873609a093bcbfb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dff2925e0c2325a873609a093bcbfb2">&#9670;&nbsp;</a></span>struct_initializer1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::struct_initializer1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structObject_1_1Initializer.html">Object::Initializer</a> *&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>構造体の変数の初期化式を生成する </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
    <tr><td class="paramname">init</td><td>初期化式</td></tr>
  </table>
  </dd>
</dl>
<p>以下のEBNF規則に従う。 <br  />
struct_initializer1 = "{" initializer ("," initializer)* ","? "}" </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l01078">1078</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="ad55930fe3333048b0d15da11252cc8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad55930fe3333048b0d15da11252cc8d2">&#9670;&nbsp;</a></span>struct_initializer2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::struct_initializer2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structObject_1_1Initializer.html">Object::Initializer</a> *&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>構造体の変数の初期化式(前後に'{}'を持たない)を読み取り生成する </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
    <tr><td class="paramname">init</td><td>初期化式</td></tr>
  </table>
  </dd>
</dl>
<p>以下のEBNF規則に従う。 <br  />
struct_initializer2 = initializer ("," initializer)* </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l01115">1115</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="ad9f212062f266ab855d4356f30a74273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f212062f266ab855d4356f30a74273">&#9670;&nbsp;</a></span>struct_members()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::struct_members </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>構造体定義のメンバの定義を読み取る </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
    <tr><td class="paramname">ty</td><td>構造体の型</td></tr>
  </table>
  </dd>
</dl>
<p>下記のEBNF規則に従う。 <br  />
 struct-members = (declspec declarator ("," declarator)* ";")* "}" </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l01760">1760</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a94f226a31ff83f09d97aaf3b7c058452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f226a31ff83f09d97aaf3b7c058452">&#9670;&nbsp;</a></span>struct_ref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::struct_ref </td>
          <td>(</td>
          <td class="paramtype">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>構造体,共用体のメンバにアクセスするノードを生成する </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>参照される構造体、共用体 </td></tr>
    <tr><td class="paramname">token</td><td>メンバの呼び出しに対応するトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>メンバに対応するノード </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l01848">1848</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a61804423873eafcd941fd45eab1c7f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61804423873eafcd941fd45eab1c7f89">&#9670;&nbsp;</a></span>struct_union_decl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; Node::struct_union_decl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>構造体,共用体の宣言、定義を読み込む </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>構造体、共用体の型</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
 struct-union-decl = identifier? ( "{" struct-members )? </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l01628">1628</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a827708315ba6c87e7d344683228bc8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827708315ba6c87e7d344683228bc8bd">&#9670;&nbsp;</a></span>to_assign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::to_assign </td>
          <td>(</td>
          <td class="paramtype">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>binary</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>演算代入式を表すノードを生成する </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binary</td><td>演算代入を行う左辺と右辺をもったノード </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>演算代入式を表すノード</dd></dl>
<p>'A op= B'を'tmp = &amp;A, *tmp = *tmp op B'に変換する </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l02514">2514</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a84c663224a5dc1847c9934dfebd230c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c663224a5dc1847c9934dfebd230c9">&#9670;&nbsp;</a></span>type_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; Node::type_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>型情報を読み取る </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>読み取った型</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
 type-name = declspec abstract-declarator </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l03347">3347</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="afcf4dcff0f0d7730933637dd16decb25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf4dcff0f0d7730933637dd16decb25">&#9670;&nbsp;</a></span>type_suffix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; Node::type_suffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>宣言を変数 or 関数か判断し結果の型を返す </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
    <tr><td class="paramname">ty</td><td>宣言されている型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>変数 or 関数の型</dd></dl>
<p>次のEBNF規則に従う。 <br  />
type-suffix = "(" function-parameters | "[" array-dimension | ε <br  />
function-parameters = parameter ("," parameter)* <br  />
parameter = declspec declarator </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l01550">1550</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a61be0c6d6aa6bbbb27c220a3ec18456f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61be0c6d6aa6bbbb27c220a3ec18456f">&#9670;&nbsp;</a></span>unary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; Node::unary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>符号付の単項を読み取る。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>対応するASTノード</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
 unary = ("+" | "-" | "*" | "&amp;" | "!" | "~") cast | ("++" | "--") unary |postfix </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l02960">2960</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="aa2fbae277939be92f332caafacdc6a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2fbae277939be92f332caafacdc6a50">&#9670;&nbsp;</a></span>union_decl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; <a class="el" href="classType.html">Type</a> &gt; Node::union_decl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>共用体の宣言、定義を読み込む </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>共用体の型</dd></dl>
<p>下記のEBNF規則に従う。 <br  />
 union-decl = struct-union-decl </p>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l01724">1724</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a05efdbd49d1642d2a93bc3654e338a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05efdbd49d1642d2a93bc3654e338a7e">&#9670;&nbsp;</a></span>union_initializer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::union_initializer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> **&#160;</td>
          <td class="paramname"><em>next_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken.html">Token</a> *&#160;</td>
          <td class="paramname"><em>current_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structObject_1_1Initializer.html">Object::Initializer</a> *&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>共用体の変数の初期化式を生成する。共用体は1要素しか初期化式をもたない。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_token</td><td>残りのトークンを返すための参照 </td></tr>
    <tr><td class="paramname">current_token</td><td>現在処理しているトークン </td></tr>
    <tr><td class="paramname">init</td><td>初期化式 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l01137">1137</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a49dbdf23f45f361e93abca72dff4e3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49dbdf23f45f361e93abca72dff4e3fe">&#9670;&nbsp;</a></span>write_buf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::write_buf </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>buf</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>整数valの内部表現を1バイトずつbuf[offset]に書き込む </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>データの書き込み先 </td></tr>
    <tr><td class="paramname">val</td><td>書き込む数値 </td></tr>
    <tr><td class="paramname">sz</td><td>書き込むサイズ（byte） </td></tr>
    <tr><td class="paramname">offset</td><td>書き込むスタート地点のオフセット </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l01283">1283</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="ae47e5c8d5ae1268077bf65b6ce450b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47e5c8d5ae1268077bf65b6ce450b4d">&#9670;&nbsp;</a></span>write_fval_buf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Node::write_fval_buf </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>buf</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>浮動小数点数valの内部表現を1バイトずつbuf[offset]に書き込む </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>データの書き込み先 </td></tr>
    <tr><td class="paramname">val</td><td>書き込む数値 </td></tr>
    <tr><td class="paramname">sz</td><td>書き込むサイズ（byte） </td></tr>
    <tr><td class="paramname">offset</td><td>書き込むスタート地点のオフセット </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l01312">1312</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a392113c6b92c9bb62f05805b360e70c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392113c6b92c9bb62f05805b360e70c0">&#9670;&nbsp;</a></span>write_gvar_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structObject_1_1Relocation.html">Object::Relocation</a> * Node::write_gvar_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structObject_1_1Relocation.html">Object::Relocation</a> *&#160;</td>
          <td class="paramname"><em>cur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structObject_1_1Initializer.html">Object::Initializer</a> *&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>buf</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>グローバル変数の初期化データを生成する </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>初期化式 </td></tr>
    <tr><td class="paramname">ty</td><td>書き込む型 </td></tr>
    <tr><td class="paramname">buf</td><td>データの書き込み先 </td></tr>
    <tr><td class="paramname">offset</td><td>オフセット </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l01352">1352</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ada3ab21e3538e4b8a943cf2cc440ef81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3ab21e3538e4b8a943cf2cc440ef81">&#9670;&nbsp;</a></span>_args</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt;<a class="el" href="classNode.html">Node</a>&gt; Node::_args</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>引数 <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00115">115</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>

</div>
</div>
<a id="a11dead16c5974879fa828e5ce0281e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11dead16c5974879fa828e5ce0281e95">&#9670;&nbsp;</a></span>_body</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt;<a class="el" href="classNode.html">Node</a>&gt; Node::_body</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ブロック内{...}またはステートメント式({...})には複数の式を入れられる </p>

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00108">108</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>

</div>
</div>
<a id="ae80f88cea76bf1bfe8437975e5412100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae80f88cea76bf1bfe8437975e5412100">&#9670;&nbsp;</a></span>_brk_label</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string Node::_brk_label = &quot;&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>breakにつけるアセンブリ内で一意なラベル名 </p>

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00126">126</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>

</div>
</div>
<a id="a2cdc6401f50b06af1c56b2362aef46a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cdc6401f50b06af1c56b2362aef46a1">&#9670;&nbsp;</a></span>_condition</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt;<a class="el" href="classNode.html">Node</a>&gt; Node::_condition</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>if文の条件 </p>

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00101">101</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>

</div>
</div>
<a id="a9fea8833104226bc686ae8f46c7a711e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fea8833104226bc686ae8f46c7a711e">&#9670;&nbsp;</a></span>_cont_label</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string Node::_cont_label = &quot;&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>continueにつけるアセンブリ内で一意なラベル名 </p>

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00127">127</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>

</div>
</div>
<a id="a5c0743a59be6b4d130d9842b46c3bf0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0743a59be6b4d130d9842b46c3bf0a">&#9670;&nbsp;</a></span>_else</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt;<a class="el" href="classNode.html">Node</a>&gt; Node::_else</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>falseのとき行う式 </p>

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00103">103</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>

</div>
</div>
<a id="a86b06a9efee3d2c68d8de039b3ca0f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b06a9efee3d2c68d8de039b3ca0f0d">&#9670;&nbsp;</a></span>_func_ty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;<a class="el" href="classType.html">Type</a>&gt; Node::_func_ty</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>関数の型 </p>

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00114">114</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>

</div>
</div>
<a id="a2ea97216fc8d04a37148b2082674c339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea97216fc8d04a37148b2082674c339">&#9670;&nbsp;</a></span>_fval</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Node::_fval = 0.0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>kindがND_NUMの場合のみ使う、数値の値(浮動小数点) </p>

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00120">120</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>

</div>
</div>
<a id="ad5fad0e27643627ba57ef7071ba759e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fad0e27643627ba57ef7071ba759e1">&#9670;&nbsp;</a></span>_goto_next</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNode.html">Node</a>* Node::_goto_next</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>gotoをまとめたリストで次のノード </p>

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00132">132</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>

</div>
</div>
<a id="a7f7a4cc5b409a7d26a40cbcad7d20614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7a4cc5b409a7d26a40cbcad7d20614">&#9670;&nbsp;</a></span>_inc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt;<a class="el" href="classNode.html">Node</a>&gt; Node::_inc</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>加算処理 </p>

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00105">105</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>

</div>
</div>
<a id="acdc97b2c849452e3c4bb78ea99e7d0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc97b2c849452e3c4bb78ea99e7d0da">&#9670;&nbsp;</a></span>_init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt;<a class="el" href="classNode.html">Node</a>&gt; Node::_init</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>初期化処理 </p>

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00104">104</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>

</div>
</div>
<a id="ab539992ca576dcd1209a7dbe15323b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab539992ca576dcd1209a7dbe15323b96">&#9670;&nbsp;</a></span>_kind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="parse_8hpp.html#adaa4ecec941fa446d7019c24371f4ff0">NodeKind</a> Node::_kind = <a class="el" href="parse_8hpp.html#adaa4ecec941fa446d7019c24371f4ff0afbe8a298d9587617545741b4c0309b24">NodeKind::ND_EXPR_STMT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ノードの種類 </p>

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00093">93</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>

</div>
</div>
<a id="aacb3743c53a6214c7bc795ec6f54d63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb3743c53a6214c7bc795ec6f54d63a">&#9670;&nbsp;</a></span>_label</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string Node::_label = &quot;&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ラベル </p>

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00130">130</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>

</div>
</div>
<a id="a90719b3c8189235c17ed5b1db87d7df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90719b3c8189235c17ed5b1db87d7df2">&#9670;&nbsp;</a></span>_lhs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt;<a class="el" href="classNode.html">Node</a>&gt; Node::_lhs</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>左辺 </p>

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00097">97</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>

</div>
</div>
<a id="a80dd03d1e2278a2ed7579fe699c4384d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80dd03d1e2278a2ed7579fe699c4384d">&#9670;&nbsp;</a></span>_member</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;<a class="el" href="structMember.html">Member</a>&gt; Node::_member</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>構造体メンバー </p>

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00111">111</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>

</div>
</div>
<a id="a62631002faea754d2d59eb087b50ce94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62631002faea754d2d59eb087b50ce94">&#9670;&nbsp;</a></span>_next</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt;<a class="el" href="classNode.html">Node</a>&gt; Node::_next</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ノードが木のrootである場合、次の木のrootノード </p>

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00094">94</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>

</div>
</div>
<a id="a7fae819c089409c1678af9bfe036ae89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fae819c089409c1678af9bfe036ae89">&#9670;&nbsp;</a></span>_pass_by_stack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::_pass_by_stack = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>引数をスタック経由で渡すか </p>

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00116">116</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>

</div>
</div>
<a id="a58f0a7fea28013d6542eebdd4ae71b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f0a7fea28013d6542eebdd4ae71b9d">&#9670;&nbsp;</a></span>_rhs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt;<a class="el" href="classNode.html">Node</a>&gt; Node::_rhs</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>右辺 </p>

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00098">98</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>

</div>
</div>
<a id="aa76f9f9d2ef94a236500ad737710d515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76f9f9d2ef94a236500ad737710d515">&#9670;&nbsp;</a></span>_then</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt;<a class="el" href="classNode.html">Node</a>&gt; Node::_then</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>trueのときに行う式 </p>

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00102">102</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>

</div>
</div>
<a id="a8ac4f88922fb98206bef10d97b6f0886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ac4f88922fb98206bef10d97b6f0886">&#9670;&nbsp;</a></span>_token</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classToken.html">Token</a>* Node::_token = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00139">139</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>

</div>
</div>
<a id="a4f00d80b1120c55f138ff212f6d2787e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f00d80b1120c55f138ff212f6d2787e">&#9670;&nbsp;</a></span>_ty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;<a class="el" href="classType.html">Type</a>&gt; Node::_ty</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>型情報 e.g. int or pointer to int </p>

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00095">95</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>

</div>
</div>
<a id="a30d7fdce09faa3d603f50740a4cee876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d7fdce09faa3d603f50740a4cee876">&#9670;&nbsp;</a></span>_unique_label</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string Node::_unique_label = &quot;&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>アセンブリ内で使う一意なラベル名 </p>

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00131">131</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>

</div>
</div>
<a id="aa2493055211201a1a42c4ab18795c326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2493055211201a1a42c4ab18795c326">&#9670;&nbsp;</a></span>_val</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t Node::_val = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>kindがND_NUMの場合のみ使う、数値の値(整数) </p>

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00119">119</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>

</div>
</div>
<a id="af08b6b660b78ac6fda3cff7b96dc9c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08b6b660b78ac6fda3cff7b96dc9c30">&#9670;&nbsp;</a></span>_var</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classObject.html">Object</a>* Node::_var = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>kindがND_VARの場合のみ使う、 オブジェクトの情報 </p>

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00123">123</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>

</div>
</div>
<a id="aaeb6b67041719db08aef7fcf264678b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb6b67041719db08aef7fcf264678b5">&#9670;&nbsp;</a></span>case_next</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNode.html">Node</a>* Node::case_next = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>switch文の各ケースのリスト </p>

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00135">135</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>

</div>
</div>
<a id="a3a2617479440480742cbc734060e8cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2617479440480742cbc734060e8cad">&#9670;&nbsp;</a></span>default_case</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNode.html">Node</a>* Node::default_case = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>switch文のdefault </p>

<p class="definition">Definition at line <a class="el" href="parse_8hpp_source.html#l00136">136</a> of file <a class="el" href="parse_8hpp_source.html">parse.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="parse_8hpp_source.html">parse.hpp</a></li>
<li><a class="el" href="parse_8cpp_source.html">parse.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classNode.html">Node</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
